## 3.2 정적 메서드를 사용하지 마세요.
[토론하기](https://www.yegor256.com/2014/05/05/oop-alternative-to-utility-classes.html)

1. 객체 대 컴퓨터 사고
    순차적인 사고방식: 컴퓨터처럼 생각하기
    CPU에게 할일을 지시 X -> 정의하기
    객체지향적으로 생각하기: 누가 누구를 정의하고, 객체들이 필요할 때 스스로 상호작용 하도록 제어하기 위함.
2. 선언형 스타일 대 명령형 스타일
    명령형 프로그래밍 (Imperative Programming) : 프로그램의 상태를 변경하는 문장을 사용해서 계산 방식을 서술
    선언형 프로그래밍 (Declarative Programming) : 제어 흐름을 서술하지 않고 계산 로직을 표현
    명령형 메서드 -> 메서드를 호출한 시점에 CPU가 즉시 결과를 계산함
    선언형 메서드 -> 실제 계산하는 시점을 결정할 수 있음.
    * 직접 성능 최적화를 제어할 수 있기 때문에 더 빠름
        정적 메서드 방식 -> 순차적으로 진행
        객체 선언형 방식 -> CPU에게 결과가 실제로 필요한 시점과 위치를 잘 결정하도록 위임.
    * 다형성
        객체를 다른 객체로부터 완전히 분리하기 위해서는 메서드나 주 초기자 어디에서도 인스턴스화를 사용하지 않아야함.
        더 낮은 결합도는 더 나은 유지보수성으로 이어짐
    * 표현력
        코드가 구현 관련된 세부사항이 감춰지고 오직 행동만 표현
    * 응집도
        객체와 정적 메서드를 혼용해서는 안됨, 절대 명령형 스타일을 사용해서는 안됨
        정적 메서드는 객체지향 소프트웨어의 암적인 존재
3. 유틸리티 클래스
    인스턴스를 생성하지 않는 껍데기 클래스 (내부 정적 메서드만 사용)
    클래스의 인스턴스가 생성되는 것을 초기자 private를 이용해서 방지
    클래스에 선언된 메서드를 제외한 어느 누구도 클래스의 인스턴스를 생성할 수 없음.
    유틸리티 클래스는 끔찍한 안티 패턴
4. 싱글톤 패턴
    끔찍한 안티패턴 절대 사용 X
    싱글톤은 상태를 캡슐화 할 수 있다? X -> 상태를 유지한다 O
    싱글톤은 분리 가능한 의존성으로 연결되어 있는데 반해, 유틸리티 클래스는 분리가 불가능한 하드 코딩된 결합도를 가짐.
    싱글톤은 전역변수 그 이상 그이하도 아님.
    => 대체해서 캡슐화를 사용할 것.
5. 함수형 프로그래밍
    PF 보다 OOP의 표현력이 더 뛰어남
6. 조합 가능한 Decorator
    Composable Decorator : 그저 다른 객체를 감싸는 객체일 뿐 (ex. Directory를 감싸는 FileName 클래스)
